// Package repository contains the data access layer implementations.
// This layer is responsible for all database operations and data persistence.
//
// DESIGN PRINCIPLE: Repositories implement interfaces defined in the domain layer,
// keeping the domain independent of infrastructure concerns.
package repository

import (
	"context"

	"github.com/user/go-boilerplate/internal/domain/entity"
	"github.com/user/go-boilerplate/internal/domain/repository"
	"gorm.io/gorm"
)

// ============================================================================
// USER REPOSITORY IMPLEMENTATION
// ============================================================================

// userRepository is the PostgreSQL implementation of repository.UserRepository.
// It uses GORM for database operations with automatic soft delete support.
type userRepository struct {
	// db is the GORM database connection instance.
	// It is injected during construction for testability.
	db *gorm.DB
}

// NewUserRepository creates a new PostgreSQL user repository.
//
// PARAMETERS:
// - db: GORM database connection (should be configured with connection pool)
//
// RETURNS: UserRepository implementation ready for use
//
// EXAMPLE:
//
//	db, _ := gorm.Open(postgres.Open(dsn), &gorm.Config{})
//	userRepo := repository.NewUserRepository(db)
func NewUserRepository(db *gorm.DB) repository.UserRepository {
	return &userRepository{db: db}
}

// GetByID retrieves a user by their unique identifier.
// Soft-deleted records are automatically excluded by GORM.
//
// SQL EQUIVALENT:
//
//	SELECT * FROM users WHERE id = $1 AND deleted_at IS NULL LIMIT 1
//
// PARAMETERS:
// - ctx: Context for query cancellation and tracing
// - id: UUID of the user to find
//
// RETURNS:
// - *entity.User: User entity if found
// - error: gorm.ErrRecordNotFound if not found
func (r *userRepository) GetByID(ctx context.Context, id string) (*entity.User, error) {
	var user entity.User

	// WithContext propagates the context for tracing and cancellation
	if err := r.db.WithContext(ctx).First(&user, "id = ?", id).Error; err != nil {
		return nil, err
	}

	return &user, nil
}

// GetByEmail retrieves a user by their email address.
// Used primarily for authentication and duplicate checking.
//
// SQL EQUIVALENT:
//
//	SELECT * FROM users WHERE email = $1 AND deleted_at IS NULL LIMIT 1
//
// SECURITY:
// - The email column is indexed for fast lookups
// - This prevents timing attacks during authentication
//
// PARAMETERS:
// - ctx: Context for query cancellation and tracing
// - email: Email address to search for
//
// RETURNS:
// - *entity.User: User entity if found
// - error: gorm.ErrRecordNotFound if not found
func (r *userRepository) GetByEmail(ctx context.Context, email string) (*entity.User, error) {
	var user entity.User

	if err := r.db.WithContext(ctx).Where("email = ?", email).First(&user).Error; err != nil {
		return nil, err
	}

	return &user, nil
}

// Create inserts a new user record into the database.
// UUID and timestamps are automatically generated by GORM hooks.
//
// SQL EQUIVALENT:
//
//	INSERT INTO users (id, email, password, name, is_active, created_at, updated_at)
//	VALUES ($1, $2, $3, $4, $5, $6, $7)
//
// SECURITY:
// - The password field should already be hashed before calling this method
// - Email uniqueness is enforced by database constraint
//
// PARAMETERS:
// - ctx: Context for query cancellation and tracing
// - user: User entity to insert (password must be pre-hashed)
//
// RETURNS:
// - error: Database error if creation fails (e.g., duplicate email constraint)
func (r *userRepository) Create(ctx context.Context, user *entity.User) error {
	return r.db.WithContext(ctx).Create(user).Error
}

// Update modifies an existing user record.
// Only non-zero fields are updated (GORM's default behavior with Save).
//
// SQL EQUIVALENT:
//
//	UPDATE users SET email=$1, name=$2, ..., updated_at=$N WHERE id=$M
//
// AUDIT:
// - UpdatedAt is automatically set by GORM
// - UpdatedBy should be set by the caller before calling Update
//
// PARAMETERS:
// - ctx: Context for query cancellation and tracing
// - user: User entity with updated fields (ID must be set)
//
// RETURNS:
// - error: Database error if update fails
func (r *userRepository) Update(ctx context.Context, user *entity.User) error {
	return r.db.WithContext(ctx).Save(user).Error
}

// Delete performs a soft delete on a user record.
// The record is preserved with a DeletedAt timestamp.
//
// SQL EQUIVALENT:
//
//	UPDATE users SET deleted_at = NOW() WHERE id = $1
//
// COMPLIANCE:
// - Data is retained for audit purposes
// - Consider data retention policies for GDPR compliance
// - Hard delete may be required after retention period
//
// PARAMETERS:
// - ctx: Context for query cancellation and tracing
// - id: UUID of the user to soft-delete
//
// RETURNS:
// - error: Database error if deletion fails
func (r *userRepository) Delete(ctx context.Context, id string) error {
	return r.db.WithContext(ctx).Delete(&entity.User{}, "id = ?", id).Error
}

// List retrieves a paginated list of users.
// Soft-deleted records are automatically excluded.
//
// SQL EQUIVALENT:
//
//	SELECT COUNT(*) FROM users WHERE deleted_at IS NULL;
//	SELECT * FROM users WHERE deleted_at IS NULL OFFSET $1 LIMIT $2;
//
// SECURITY:
// - This endpoint should be protected (admin only)
// - Consider implementing column-level access control
//
// PERFORMANCE:
// - Uses separate count and data queries
// - Consider adding indexes for frequently filtered columns
//
// PARAMETERS:
// - ctx: Context for query cancellation and tracing
// - offset: Number of records to skip
// - limit: Maximum number of records to return
//
// RETURNS:
// - []*entity.User: List of user entities
// - int64: Total count for pagination
// - error: Database error if query fails
func (r *userRepository) List(ctx context.Context, offset, limit int) ([]*entity.User, int64, error) {
	var users []*entity.User
	var total int64

	// Get total count for pagination metadata
	if err := r.db.WithContext(ctx).Model(&entity.User{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}

	// Get paginated results
	if err := r.db.WithContext(ctx).Offset(offset).Limit(limit).Find(&users).Error; err != nil {
		return nil, 0, err
	}

	return users, total, nil
}
